/*
 * scorecard
 *
 * inital pass at scorecard API
 *
 * API version: 1.0
 * Contact: mitchell.harvey@arup.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"fmt"
	"net/http"
	"sort"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	Lookups "github.com/mharv/scorecard-backend/calculations"
	Config "github.com/mharv/scorecard-backend/db"
)

type DesignerAverageScore struct {
	Designer     string  `json:"designer"`
	AverageScore float64 `json:"averageScore"`
}

type RegionalScores struct {
	Name         string  `json:"name"`
	Count        int     `json:"count"`
	AverageScore float64 `json:"averageScore"`
}

// regional scores is an array for now, in case of
// hardcoding the response struct with region name fields
type GlobalStoreScoresResponse struct {
	GlobalAverage  float64          `json:"globalAverage"`
	GlobalHighest  Store            `json:"globalHighest"`
	GlobalLowest   Store            `json:"globalLowest"`
	RegionalScores []RegionalScores `json:"regionalScores"`
}

type MaterialInstanceHistoryResponse struct {
	Instance MaterialInstance          `json:"instance"`
	History  []MaterialInstanceHistory `json:"history"`
}

type CategoryScoresResponse struct {
	GlobalFlooringAverage        float64 `json:"globalFlooringAverage"`
	GlobalWallAverage            float64 `json:"globalWallAverage"`
	GlobalCeilingAverage         float64 `json:"globalCeilingAverage"`
	GlobalFacadeAverage          float64 `json:"globalFacadeAverage"`
	GlobalPOSAverage             float64 `json:"globalPOSAverage"`
	GlobalProductShelvingAverage float64 `json:"globalProductShelvingAverage"`
	GlobalBOHAverage             float64 `json:"globalBOHAverage"`
	GlobalBasinAverage           float64 `json:"globalBasinAverage"`
	GlobalFurnitureAverage       float64 `json:"globalFurnitureAverage"`
	GlobalLightingAverage        float64 `json:"globalLightingAverage"`
	GlobalFixturesAverage        float64 `json:"globalFixturesAverage"`
	GlobalCSFAverage             float64 `json:"globalCSFAverage"`
	GlobalFFAverage              float64 `json:"globalFFAverage"`
	GlobalMUAverage              float64 `json:"globalMUAverage"`
}

type ManufacturerSourcingCounters struct {
	Globally   int `json:"globally"`
	Regionally int `json:"regionally"`
	Locally    int `json:"locally"`
}

type RawMaterialCounters struct {
	VGM   int `json:"vgm"`
	PRPVG int `json:"prpvg"`
	RecM  int `json:"recm"`
	ReuM  int `json:"reum"`
	RetM  int `json:"retm"`
}

type EndOfLifeCounters struct {
	NR    int `json:"nr"`
	PR    int `json:"pr"`
	FTRAD int `json:"ftrad"`
	FR    int `json:"fr"`
	RP    int `json:"rp"`
	ATBRR int `json:"atbrr"`
	TBS   int `json:"tbs"`
}

type MaterialCountsResponse struct {
	EndOfLifeCounters            EndOfLifeCounters            `json:"endOfLifeCounters"`
	RawMaterialCounters          RawMaterialCounters          `json:"rawMaterialCounters"`
	ManufacturerSourcingCounters ManufacturerSourcingCounters `json:"manufacturerSourcingCounters"`
}

type MaterialScoresResponse struct {
	HighestRatedMaterials []MaterialInstance `json:"highestRatedMaterials"`
	LowestRatedMaterials  []MaterialInstance `json:"lowestRatedMaterials"`
}

type ScoresArchitectIdResponse struct {
	AverageStoreScore float32 `json:"averageStoreScore"`
	HighestStoreScore float32 `json:"highestStoreScore"`
}

func setMaterialScores(material *MaterialInstance) {
	// set material category
	material.Category = Lookups.CategoryLookup[material.SubCategory]
	// set circularity assessment
	material.CircularityAssessment = Lookups.CircularityAssessment[material.EndOfLifeAssessment]
	// set manufacturer location score
	material.ManufacturerLocationScore = Lookups.Sourcing[material.ManufacturerLocation]
	// set raw material score
	material.RawMaterialScore = Lookups.ManufacturingMaterials[material.RawMaterial]
	// set end of life assessment score
	material.EndOfLifeAssessmentScore = Lookups.EndOfLifeSustainability[material.EndOfLifeAssessment]
	// set set product certification score
	material.ProductCertificationScore = Lookups.Certifications[material.ProductCertification]
	// apply weights and sum
	material.TotalScore = (material.ManufacturerLocationScore * Lookups.ScoreWeights["Manufacturer Location"]) +
		(material.RawMaterialScore * Lookups.ScoreWeights["Raw material"]) +
		(material.EndOfLifeAssessmentScore * Lookups.ScoreWeights["End of life assessment"]) +
		(material.ProductCertificationScore * Lookups.ScoreWeights["Product Certification"])

	// calculate A1A3 and A4 carbon factors here
	// get epicMaterial
	var epicMaterial EpicMaterial

	if result := Config.DB.Where("material = ?", material.ItemType).Find(&epicMaterial); result.Error != nil {
		fmt.Println("error getting material stores")
	}

	fmt.Println(epicMaterial)
	// possibly do unit conversion here if needed?

	material.A1A3CarbonFactor = material.MaterialQuantity *
		Lookups.ManufacturingMaterialsLCA[material.RawMaterial] *
		epicMaterial.EmbodiedGHGE

	var travelFactor float32
	if material.ManufacturerLocation == "Locally" {
		travelFactor = Lookups.TravelFactors["Locally"]
	} else {
		travelFactor = Lookups.TravelFactors[material.ManufacturerLocation+material.PrimaryTransportMethod]
	}

	material.A4CarbonFactor = travelFactor * material.MaterialQuantity

}

func average(scores []float32) float32 {
	n := len(scores)
	if n == 0 {
		return 0
	}

	var sum float32 = 0
	for i := 0; i < n; i++ {

		// adding the values of
		// array to the variable sum
		sum += (scores[i])
	}
	result := (float32(sum)) / (float32(n))
	return result
}

func averageFloat64(scores []float64) float64 {
	n := len(scores)
	if n == 0 {
		return 0
	}

	var sum float64 = 0
	for i := 0; i < n; i++ {

		// adding the values of
		// array to the variable sum
		sum += (scores[i])
	}
	result := (float64(sum)) / (float64(n))
	return result
}

func setStoreScores(storeId int32) {
	// get all materials with storeId
	fmt.Println(storeId)
	// sql query for materials by store id
	id := storeId
	var materialInstances []MaterialInstance

	if result := Config.DB.Where("storeId = ?", id).Find(&materialInstances); result.Error != nil {
		fmt.Println("error getting material stores")
	}

	var tempCategoryCSF []float32
	var tempCategoryMU []float32
	var tempCategoryFF []float32
	// manufacturer location arrays for sub categories
	var tempSubCategoryFlooringManLoc []float32
	var tempSubCategoryWallManLoc []float32
	var tempSubCategoryCeilingManLoc []float32
	var tempSubCategoryFacadeManLoc []float32
	var tempSubCategoryPOSManLoc []float32
	var tempSubCategoryProdShelvingManLoc []float32
	var tempSubCategoryBOHManLoc []float32
	var tempSubCategoryBasinManLoc []float32
	var tempSubCategoryFurnitureManLoc []float32
	var tempSubCategoryLightingManLoc []float32
	var tempSubCategoryFixturesManLoc []float32
	// raw material arrays for sub categories
	var tempSubCategoryFlooringRawMat []float32
	var tempSubCategoryWallRawMat []float32
	var tempSubCategoryCeilingRawMat []float32
	var tempSubCategoryFacadeRawMat []float32
	var tempSubCategoryPOSRawMat []float32
	var tempSubCategoryProdShelvingRawMat []float32
	var tempSubCategoryBOHRawMat []float32
	var tempSubCategoryBasinRawMat []float32
	var tempSubCategoryFurnitureRawMat []float32
	var tempSubCategoryLightingRawMat []float32
	var tempSubCategoryFixturesRawMat []float32
	// EOL assessment arrays for sub categories
	var tempSubCategoryFlooringEOLAssessment []float32
	var tempSubCategoryWallEOLAssessment []float32
	var tempSubCategoryCeilingEOLAssessment []float32
	var tempSubCategoryFacadeEOLAssessment []float32
	var tempSubCategoryPOSEOLAssessment []float32
	var tempSubCategoryProdShelvingEOLAssessment []float32
	var tempSubCategoryBOHEOLAssessment []float32
	var tempSubCategoryBasinEOLAssessment []float32
	var tempSubCategoryFurnitureEOLAssessment []float32
	var tempSubCategoryLightingEOLAssessment []float32
	var tempSubCategoryFixturesEOLAssessment []float32
	// product certification arrays for sub categories
	var tempSubCategoryFlooringProdCert []float32
	var tempSubCategoryWallProdCert []float32
	var tempSubCategoryCeilingProdCert []float32
	var tempSubCategoryFacadeProdCert []float32
	var tempSubCategoryPOSProdCert []float32
	var tempSubCategoryProdShelvingProdCert []float32
	var tempSubCategoryBOHProdCert []float32
	var tempSubCategoryBasinProdCert []float32
	var tempSubCategoryFurnitureProdCert []float32
	var tempSubCategoryLightingProdCert []float32
	var tempSubCategoryFixturesProdCert []float32

	var A1A3CarbonFactors float32 = 0.0
	var A4CarbonFactors float32 = 0.0

	// loop through array and get scores into temp arrays for each category and sub category
	if len(materialInstances) > 0 {
		for _, material := range materialInstances {
			// get carbon factors
			A1A3CarbonFactors += material.A1A3CarbonFactor
			A4CarbonFactors += material.A4CarbonFactor

			// get category scores
			if material.Category == "Core structure & finish" {
				tempCategoryCSF = append(tempCategoryCSF, material.TotalScore)
			}
			if material.Category == "Module units" {
				tempCategoryMU = append(tempCategoryMU, material.TotalScore)
			}
			if material.Category == "Furniture & fittings" {
				tempCategoryFF = append(tempCategoryFF, material.TotalScore)
			}
			// get sub category scores
			if material.SubCategory == "Flooring" {
				tempSubCategoryFlooringManLoc = append(tempSubCategoryFlooringManLoc, material.ManufacturerLocationScore)
				tempSubCategoryFlooringRawMat = append(tempSubCategoryFlooringRawMat, material.RawMaterialScore)
				tempSubCategoryFlooringEOLAssessment = append(tempSubCategoryFlooringEOLAssessment, material.EndOfLifeAssessmentScore)
				tempSubCategoryFlooringProdCert = append(tempSubCategoryFlooringProdCert, material.ProductCertificationScore)
			}
			if material.SubCategory == "Wall" {
				tempSubCategoryWallManLoc = append(tempSubCategoryWallManLoc, material.ManufacturerLocationScore)
				tempSubCategoryWallRawMat = append(tempSubCategoryWallRawMat, material.RawMaterialScore)
				tempSubCategoryWallEOLAssessment = append(tempSubCategoryWallEOLAssessment, material.EndOfLifeAssessmentScore)
				tempSubCategoryWallProdCert = append(tempSubCategoryWallProdCert, material.ProductCertificationScore)
			}
			if material.SubCategory == "Ceiling" {
				tempSubCategoryCeilingManLoc = append(tempSubCategoryCeilingManLoc, material.ManufacturerLocationScore)
				tempSubCategoryCeilingRawMat = append(tempSubCategoryCeilingRawMat, material.RawMaterialScore)
				tempSubCategoryCeilingEOLAssessment = append(tempSubCategoryCeilingEOLAssessment, material.EndOfLifeAssessmentScore)
				tempSubCategoryCeilingProdCert = append(tempSubCategoryCeilingProdCert, material.ProductCertificationScore)
			}
			if material.SubCategory == "Facade" {
				tempSubCategoryFacadeManLoc = append(tempSubCategoryFacadeManLoc, material.ManufacturerLocationScore)
				tempSubCategoryFacadeRawMat = append(tempSubCategoryFacadeRawMat, material.RawMaterialScore)
				tempSubCategoryFacadeEOLAssessment = append(tempSubCategoryFacadeEOLAssessment, material.EndOfLifeAssessmentScore)
				tempSubCategoryFacadeProdCert = append(tempSubCategoryFacadeProdCert, material.ProductCertificationScore)
			}
			if material.SubCategory == "POS" {
				tempSubCategoryPOSManLoc = append(tempSubCategoryPOSManLoc, material.ManufacturerLocationScore)
				tempSubCategoryPOSRawMat = append(tempSubCategoryPOSRawMat, material.RawMaterialScore)
				tempSubCategoryPOSEOLAssessment = append(tempSubCategoryPOSEOLAssessment, material.EndOfLifeAssessmentScore)
				tempSubCategoryPOSProdCert = append(tempSubCategoryPOSProdCert, material.ProductCertificationScore)
			}
			if material.SubCategory == "Product shelving" {
				tempSubCategoryProdShelvingManLoc = append(tempSubCategoryProdShelvingManLoc, material.ManufacturerLocationScore)
				tempSubCategoryProdShelvingRawMat = append(tempSubCategoryProdShelvingRawMat, material.RawMaterialScore)
				tempSubCategoryProdShelvingEOLAssessment = append(tempSubCategoryProdShelvingEOLAssessment, material.EndOfLifeAssessmentScore)
				tempSubCategoryProdShelvingProdCert = append(tempSubCategoryProdShelvingProdCert, material.ProductCertificationScore)
			}
			if material.SubCategory == "BOH" {
				tempSubCategoryBOHManLoc = append(tempSubCategoryBOHManLoc, material.ManufacturerLocationScore)
				tempSubCategoryBOHRawMat = append(tempSubCategoryBOHRawMat, material.RawMaterialScore)
				tempSubCategoryBOHEOLAssessment = append(tempSubCategoryBOHEOLAssessment, material.EndOfLifeAssessmentScore)
				tempSubCategoryBOHProdCert = append(tempSubCategoryBOHProdCert, material.ProductCertificationScore)
			}
			if material.SubCategory == "Basin" {
				tempSubCategoryBasinManLoc = append(tempSubCategoryBasinManLoc, material.ManufacturerLocationScore)
				tempSubCategoryBasinRawMat = append(tempSubCategoryBasinRawMat, material.RawMaterialScore)
				tempSubCategoryBasinEOLAssessment = append(tempSubCategoryBasinEOLAssessment, material.EndOfLifeAssessmentScore)
				tempSubCategoryBasinProdCert = append(tempSubCategoryBasinProdCert, material.ProductCertificationScore)
			}
			if material.SubCategory == "Furniture" {
				tempSubCategoryFurnitureManLoc = append(tempSubCategoryFurnitureManLoc, material.ManufacturerLocationScore)
				tempSubCategoryFurnitureRawMat = append(tempSubCategoryFurnitureRawMat, material.RawMaterialScore)
				tempSubCategoryFurnitureEOLAssessment = append(tempSubCategoryFurnitureEOLAssessment, material.EndOfLifeAssessmentScore)
				tempSubCategoryFurnitureProdCert = append(tempSubCategoryFurnitureProdCert, material.ProductCertificationScore)
			}
			if material.SubCategory == "Lighting" {
				tempSubCategoryLightingManLoc = append(tempSubCategoryLightingManLoc, material.ManufacturerLocationScore)
				tempSubCategoryLightingRawMat = append(tempSubCategoryLightingRawMat, material.RawMaterialScore)
				tempSubCategoryLightingEOLAssessment = append(tempSubCategoryLightingEOLAssessment, material.EndOfLifeAssessmentScore)
				tempSubCategoryLightingProdCert = append(tempSubCategoryLightingProdCert, material.ProductCertificationScore)
			}
			if material.SubCategory == "Fixtures" {
				tempSubCategoryFixturesManLoc = append(tempSubCategoryFixturesManLoc, material.ManufacturerLocationScore)
				tempSubCategoryFixturesRawMat = append(tempSubCategoryFixturesRawMat, material.RawMaterialScore)
				tempSubCategoryFixturesEOLAssessment = append(tempSubCategoryFixturesEOLAssessment, material.EndOfLifeAssessmentScore)
				tempSubCategoryFixturesProdCert = append(tempSubCategoryFixturesProdCert, material.ProductCertificationScore)
			}
		}
	}

	var catCSFScore = average(tempCategoryCSF)
	var catMUScore = average(tempCategoryMU)
	var catFFScore = average(tempCategoryFF)

	// perform calculations and set variables
	// average each sub category value for manufacturerLocation, rawMaterial, EOLassessmnet, produc cert
	// do multiplier using scoreWeights for each sub category

	var subCatFlooringScore = average(tempSubCategoryFlooringManLoc)*Lookups.ScoreWeights["Manufacturer Location"] +
		average(tempSubCategoryFlooringRawMat)*Lookups.ScoreWeights["Raw material"] +
		average(tempSubCategoryFlooringEOLAssessment)*Lookups.ScoreWeights["End of life assessment"] +
		average(tempSubCategoryFlooringProdCert)*Lookups.ScoreWeights["Product Certification"]

	var subCatWallScore = average(tempSubCategoryWallManLoc)*Lookups.ScoreWeights["Manufacturer Location"] +
		average(tempSubCategoryWallRawMat)*Lookups.ScoreWeights["Raw material"] +
		average(tempSubCategoryWallEOLAssessment)*Lookups.ScoreWeights["End of life assessment"] +
		average(tempSubCategoryWallProdCert)*Lookups.ScoreWeights["Product Certification"]

	var subCatCeilingScore = average(tempSubCategoryCeilingManLoc)*Lookups.ScoreWeights["Manufacturer Location"] +
		average(tempSubCategoryCeilingRawMat)*Lookups.ScoreWeights["Raw material"] +
		average(tempSubCategoryCeilingEOLAssessment)*Lookups.ScoreWeights["End of life assessment"] +
		average(tempSubCategoryCeilingProdCert)*Lookups.ScoreWeights["Product Certification"]

	var subCatFacadeScore = average(tempSubCategoryFacadeManLoc)*Lookups.ScoreWeights["Manufacturer Location"] +
		average(tempSubCategoryFacadeRawMat)*Lookups.ScoreWeights["Raw material"] +
		average(tempSubCategoryFacadeEOLAssessment)*Lookups.ScoreWeights["End of life assessment"] +
		average(tempSubCategoryFacadeProdCert)*Lookups.ScoreWeights["Product Certification"]

	var subCatPOSScore = average(tempSubCategoryPOSManLoc)*Lookups.ScoreWeights["Manufacturer Location"] +
		average(tempSubCategoryPOSRawMat)*Lookups.ScoreWeights["Raw material"] +
		average(tempSubCategoryPOSEOLAssessment)*Lookups.ScoreWeights["End of life assessment"] +
		average(tempSubCategoryPOSProdCert)*Lookups.ScoreWeights["Product Certification"]

	var subCatProdShelvingScore = average(tempSubCategoryProdShelvingManLoc)*Lookups.ScoreWeights["Manufacturer Location"] +
		average(tempSubCategoryProdShelvingRawMat)*Lookups.ScoreWeights["Raw material"] +
		average(tempSubCategoryProdShelvingEOLAssessment)*Lookups.ScoreWeights["End of life assessment"] +
		average(tempSubCategoryProdShelvingProdCert)*Lookups.ScoreWeights["Product Certification"]

	var subCatBOHScore = average(tempSubCategoryBOHManLoc)*Lookups.ScoreWeights["Manufacturer Location"] +
		average(tempSubCategoryBOHRawMat)*Lookups.ScoreWeights["Raw material"] +
		average(tempSubCategoryBOHEOLAssessment)*Lookups.ScoreWeights["End of life assessment"] +
		average(tempSubCategoryBOHProdCert)*Lookups.ScoreWeights["Product Certification"]

	var subCatBasinScore = average(tempSubCategoryBasinManLoc)*Lookups.ScoreWeights["Manufacturer Location"] +
		average(tempSubCategoryBasinRawMat)*Lookups.ScoreWeights["Raw material"] +
		average(tempSubCategoryBasinEOLAssessment)*Lookups.ScoreWeights["End of life assessment"] +
		average(tempSubCategoryBasinProdCert)*Lookups.ScoreWeights["Product Certification"]

	var subCatFurnitureScore = average(tempSubCategoryFurnitureManLoc)*Lookups.ScoreWeights["Manufacturer Location"] +
		average(tempSubCategoryFurnitureRawMat)*Lookups.ScoreWeights["Raw material"] +
		average(tempSubCategoryFurnitureEOLAssessment)*Lookups.ScoreWeights["End of life assessment"] +
		average(tempSubCategoryFurnitureProdCert)*Lookups.ScoreWeights["Product Certification"]

	var subCatLightingScore = average(tempSubCategoryLightingManLoc)*Lookups.ScoreWeights["Manufacturer Location"] +
		average(tempSubCategoryLightingRawMat)*Lookups.ScoreWeights["Raw material"] +
		average(tempSubCategoryLightingEOLAssessment)*Lookups.ScoreWeights["End of life assessment"] +
		average(tempSubCategoryLightingProdCert)*Lookups.ScoreWeights["Product Certification"]

	var subCatFixturesScore = average(tempSubCategoryFixturesManLoc)*Lookups.ScoreWeights["Manufacturer Location"] +
		average(tempSubCategoryFixturesRawMat)*Lookups.ScoreWeights["Raw material"] +
		average(tempSubCategoryFixturesEOLAssessment)*Lookups.ScoreWeights["End of life assessment"] +
		average(tempSubCategoryFixturesProdCert)*Lookups.ScoreWeights["Product Certification"]

	// multiply by subcategorycontribution lookup and add results together
	// save to totalScore column
	var totalScore float32 = subCatFlooringScore*Lookups.SubCategoryContribution["Flooring"] +
		subCatWallScore*Lookups.SubCategoryContribution["Wall"] +
		subCatCeilingScore*Lookups.SubCategoryContribution["Ceiling"] +
		subCatFacadeScore*Lookups.SubCategoryContribution["Facade"] +
		subCatPOSScore*Lookups.SubCategoryContribution["POS"] +
		subCatProdShelvingScore*Lookups.SubCategoryContribution["Product shelving"] +
		subCatBOHScore*Lookups.SubCategoryContribution["BOH"] +
		subCatBasinScore*Lookups.SubCategoryContribution["Basin"] +
		subCatFurnitureScore*Lookups.SubCategoryContribution["Furniture"] +
		subCatLightingScore*Lookups.SubCategoryContribution["Lighting"] +
		subCatFixturesScore*Lookups.SubCategoryContribution["Fixtures"]

	fmt.Println("totalscore: ")
	fmt.Println(totalScore)

	// save changes to store
	var store Store

	if result := Config.DB.Where("id = ?", id).First(&store); result.Error != nil {
		fmt.Println("error getting store")
	} else {

		store.CatCSFScore = catCSFScore
		store.CatMUScore = catMUScore
		store.CatFFScore = catFFScore
		store.SubCatFlooringScore = subCatFlooringScore
		store.SubCatWallScore = subCatWallScore
		store.SubCatCeilingScore = subCatCeilingScore
		store.SubCatFacadeScore = subCatFacadeScore
		store.SubCatPOSScore = subCatPOSScore
		store.SubCatProdShelvingScore = subCatProdShelvingScore
		store.SubCatBOHScore = subCatBOHScore
		store.SubCatBasinScore = subCatBasinScore
		store.SubCatFurnitureScore = subCatFurnitureScore
		store.SubCatLightingScore = subCatLightingScore
		store.SubCatFixturesScore = subCatFixturesScore
		store.TotalScoreUnweighted = totalScore
		// store level GHG calc here

		embodiedCarbon := (A1A3CarbonFactors + A4CarbonFactors) / store.RetailSqm

		store.GHGEmissions = embodiedCarbon

		fmt.Println(store.GHGEmissions)

		var emissionSize string
		if store.LocationType == "Store" {
			if embodiedCarbon <= Lookups.RetailStoreEmissions["Low"] {
				emissionSize = "Low"
			}
			if embodiedCarbon > Lookups.RetailStoreEmissions["Low"] && embodiedCarbon <= Lookups.RetailStoreEmissions["Medium"] {
				emissionSize = "Medium"
			}
			if embodiedCarbon > Lookups.RetailStoreEmissions["Medium"] {
				emissionSize = "High"
			}
		} else {
			if embodiedCarbon <= Lookups.RetailCounterEmissions["Low"] {
				emissionSize = "Low"
			}
			if embodiedCarbon > Lookups.RetailCounterEmissions["Low"] && embodiedCarbon <= Lookups.RetailCounterEmissions["Medium"] {
				emissionSize = "Medium"
			}
			if embodiedCarbon > Lookups.RetailCounterEmissions["Medium"] {
				emissionSize = "High"
			}
		}

		store.TotalScore = totalScore * Lookups.RetailEmissionsMultiplier[emissionSize]

		if result := Config.DB.Save(&store); result.Error != nil {
			fmt.Println("saving store failed")
		} else {
			fmt.Println("saving store success")
		}
	}
}

// Index is the index handler.
func Index(c *gin.Context) {
	c.String(http.StatusOK, "Hello, Aesop!")
}

func TopDesigners(c *gin.Context) {
	n := c.Params.ByName("n")
	i, err := strconv.Atoi(n)
	if err != nil {
		c.AbortWithStatus(http.StatusNotFound)
	}

	// get all user IDs that are designer/architects
	var users []User
	if result := Config.DB.Where("accessLevel = ?", "pm/architect").Find(&users); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	}

	// get all stores
	var stores []Store
	if result := Config.DB.Where("storeStatus <> ?", "DRAFT").Find(&stores); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	}
	// for each designer ID, get an array of store scores
	// get average of each designer score array,

	var designerAverages []DesignerAverageScore

	for _, designer := range users {
		var tempDesignerScores []float64
		for _, store := range stores {
			if store.ArchitectId == designer.Id {
				tempDesignerScores = append(tempDesignerScores, float64(store.TotalScore))
			}
		}
		tempDesignerAverageScore := DesignerAverageScore{
			Designer:     designer.Email,
			AverageScore: averageFloat64(tempDesignerScores),
		}
		designerAverages = append(designerAverages, tempDesignerAverageScore)
	}

	//  sort highest to lowest.
	sort.Slice(designerAverages[:], func(i, j int) bool {
		return designerAverages[i].AverageScore > designerAverages[j].AverageScore
	})

	// get slice of top n
	if i > len(users) {
		i = len(users)
	}

	c.JSON(http.StatusOK, designerAverages[:i])
}
func TopStoreScores(c *gin.Context) {
	n := c.Params.ByName("n")

	i, err := strconv.Atoi(n)
	if err != nil {
		c.AbortWithStatus(http.StatusNotFound)
	}

	var stores []Store

	if result := Config.DB.Where("storeStatus <> ?", "DRAFT").Find(&stores); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		// if value provided is greater than number of stores in db
		if i > len(stores) {
			i = len(stores)
		}

		// sort stores by total score
		sort.Slice(stores[:], func(i, j int) bool {
			return stores[i].TotalScore > stores[j].TotalScore
		})

		response := stores[:i]

		c.JSON(http.StatusOK, response)
	}
}
func GlobalStoreScores(c *gin.Context) {
	var stores []Store

	if result := Config.DB.Where("storeStatus <> ?", "DRAFT").Find(&stores); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {

		// create regional temp arrays

		var tempStoreScores []float64
		var tempANZScores []float64
		var tempAsiaScores []float64
		var tempEuropeScores []float64
		var tempAmericasScores []float64

		for _, store := range stores {
			// do conditional logic on region name and append to approriate array
			tempStoreScores = append(tempStoreScores, float64(store.TotalScore))
			if store.Region == "ANZ" {
				tempANZScores = append(tempANZScores, float64(store.TotalScore))
			}
			if store.Region == "Asia" {
				tempAsiaScores = append(tempAsiaScores, float64(store.TotalScore))
			}
			if store.Region == "Europe" {
				tempEuropeScores = append(tempEuropeScores, float64(store.TotalScore))
			}
			if store.Region == "Americas" {
				tempAmericasScores = append(tempAmericasScores, float64(store.TotalScore))
			}
		}

		globalAverage := averageFloat64(tempStoreScores)

		// get highest and lowest scores, sort and get
		globalStoreScoreLength := len(tempStoreScores)
		sort.Float64s(tempStoreScores)
		// globalHighest := tempStoreScores[globalStoreScoreLength-1]
		// globalLowest := tempStoreScores[0]

		// sort materials by total score get highest
		sort.Slice(stores[:], func(i, j int) bool {
			return stores[i].TotalScore > stores[j].TotalScore
		})

		globalHighest := stores[0]

		globalLowest := stores[globalStoreScoreLength-1]

		var regionalScores []RegionalScores

		// append each region to regionalScores
		regionalScores = append(regionalScores, RegionalScores{"ANZ", len(tempANZScores), averageFloat64(tempANZScores)})
		regionalScores = append(regionalScores, RegionalScores{"Asia", len(tempAsiaScores), averageFloat64(tempAsiaScores)})
		regionalScores = append(regionalScores, RegionalScores{"Europe", len(tempEuropeScores), averageFloat64(tempEuropeScores)})
		regionalScores = append(regionalScores, RegionalScores{"Americas", len(tempAmericasScores), averageFloat64(tempAmericasScores)})

		response := GlobalStoreScoresResponse{
			GlobalAverage:  globalAverage,
			GlobalHighest:  globalHighest,
			GlobalLowest:   globalLowest,
			RegionalScores: regionalScores}

		// fmt.Println(response)

		c.JSON(http.StatusOK, response)
	}
}

func MaterialCounts(c *gin.Context) {
	var materials []MaterialInstance

	if result := Config.DB.Find(&materials); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {

		// create raw material eol and manufacturer sourcing counters
		globally := 0
		regionally := 0
		locally := 0
		vgm := 0
		prpvg := 0
		recm := 0
		reum := 0
		retm := 0
		nr := 0
		pr := 0
		ftrad := 0
		fr := 0
		rp := 0
		atbrr := 0
		tbs := 0

		for _, material := range materials {
			if material.EndOfLifeAssessment == "Not recyclable" {
				nr += 1
			}
			if material.EndOfLifeAssessment == "Part recyclable" {
				pr += 1
			}
			if material.EndOfLifeAssessment == "Finish to remain after decomission" {
				ftrad += 1
			}
			if material.EndOfLifeAssessment == "Fully recyclable" {
				fr += 1
			}
			if material.EndOfLifeAssessment == "Recycling program" {
				rp += 1
			}
			if material.EndOfLifeAssessment == "Able to be reused/repurposed" {
				atbrr += 1
			}
			if material.EndOfLifeAssessment == "Take Back Scheme" {
				tbs += 1
			}

			if material.RawMaterial == "Virgin grade material" {
				vgm += 1
			}
			if material.RawMaterial == "Part recycled, part virgin grade" {
				prpvg += 1
			}
			if material.RawMaterial == "Recycled material" {
				recm += 1
			}
			if material.RawMaterial == "Reused material" {
				reum += 1
			}
			if material.RawMaterial == "Retained material" {
				retm += 1
			}

			if material.ManufacturerLocation == "Globally" {
				globally += 1
			}
			if material.ManufacturerLocation == "Regionally" {
				regionally += 1
			}
			if material.ManufacturerLocation == "Locally" {
				locally += 1
			}
		}

		manufacturerSourcingCounters := ManufacturerSourcingCounters{
			Globally:   globally,
			Regionally: regionally,
			Locally:    locally,
		}

		rawMaterialCounters := RawMaterialCounters{
			VGM:   vgm,
			PRPVG: prpvg,
			RecM:  recm,
			ReuM:  reum,
			RetM:  retm,
		}

		endOfLifeCounters := EndOfLifeCounters{
			NR:    nr,
			PR:    pr,
			FTRAD: ftrad,
			FR:    fr,
			RP:    rp,
			ATBRR: atbrr,
			TBS:   tbs,
		}

		response := MaterialCountsResponse{
			EndOfLifeCounters:            endOfLifeCounters,
			RawMaterialCounters:          rawMaterialCounters,
			ManufacturerSourcingCounters: manufacturerSourcingCounters,
		}

		c.JSON(http.StatusOK, response)
	}
}
func CategoryScores(c *gin.Context) {
	var materials []MaterialInstance

	if result := Config.DB.Find(&materials); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {

		// create category and subcat temp arrays

		var tempFlooringScores []float64
		var tempWallScores []float64
		var tempCeilingScores []float64
		var tempFacadeScores []float64
		var tempPOSScores []float64
		var tempProdShelvingScores []float64
		var tempBOHScores []float64
		var tempBasinScores []float64
		var tempFurnitureScores []float64
		var tempLightingScores []float64
		var tempFixturesScores []float64

		var tempCSFScores []float64
		var tempMUScores []float64
		var tempFFScores []float64

		for _, material := range materials {
			// do conditional logic on subcat and cat name, append to approriate array
			if material.SubCategory == "Flooring" {
				tempFlooringScores = append(tempFlooringScores, float64(material.TotalScore))
			}
			if material.SubCategory == "Wall" {
				tempWallScores = append(tempWallScores, float64(material.TotalScore))
			}
			if material.SubCategory == "Ceiling" {
				tempCeilingScores = append(tempCeilingScores, float64(material.TotalScore))
			}
			if material.SubCategory == "Facade" {
				tempFacadeScores = append(tempFacadeScores, float64(material.TotalScore))
			}
			if material.SubCategory == "POS" {
				tempPOSScores = append(tempPOSScores, float64(material.TotalScore))
			}
			if material.SubCategory == "Product shelving" {
				tempProdShelvingScores = append(tempProdShelvingScores, float64(material.TotalScore))
			}
			if material.SubCategory == "BOH" {
				tempBOHScores = append(tempBOHScores, float64(material.TotalScore))
			}
			if material.SubCategory == "Basin" {
				tempBasinScores = append(tempBasinScores, float64(material.TotalScore))
			}
			if material.SubCategory == "Furniture" {
				tempFurnitureScores = append(tempFurnitureScores, float64(material.TotalScore))
			}
			if material.SubCategory == "Lighting" {
				tempLightingScores = append(tempLightingScores, float64(material.TotalScore))
			}
			if material.SubCategory == "Fixtures" {
				tempFixturesScores = append(tempFixturesScores, float64(material.TotalScore))
			}

			if material.Category == "Core structure & finish" {
				tempCSFScores = append(tempCSFScores, float64(material.TotalScore))
			}
			if material.Category == "Module units" {
				tempMUScores = append(tempMUScores, float64(material.TotalScore))
			}
			if material.Category == "Furniture & fittings" {
				tempFFScores = append(tempFFScores, float64(material.TotalScore))
			}
		}

		globalFlooringAverage := averageFloat64(tempFlooringScores)
		globalWallAverage := averageFloat64(tempWallScores)
		globalCeilingAverage := averageFloat64(tempCeilingScores)
		globalFacadeAverage := averageFloat64(tempFacadeScores)
		globalPOSAverage := averageFloat64(tempPOSScores)
		globalProductShelvingAverage := averageFloat64(tempProdShelvingScores)
		globalBOHAverage := averageFloat64(tempBOHScores)
		globalBasinAverage := averageFloat64(tempBasinScores)
		globalFurnitureAverage := averageFloat64(tempFurnitureScores)
		globalLightingAverage := averageFloat64(tempLightingScores)
		globalFixturesAverage := averageFloat64(tempFixturesScores)

		globalCSFAverage := averageFloat64(tempCSFScores)
		globalFFAverage := averageFloat64(tempFFScores)
		globalMUAverage := averageFloat64(tempMUScores)

		response := CategoryScoresResponse{
			GlobalFlooringAverage:        globalFlooringAverage,
			GlobalWallAverage:            globalWallAverage,
			GlobalCeilingAverage:         globalCeilingAverage,
			GlobalFacadeAverage:          globalFacadeAverage,
			GlobalPOSAverage:             globalPOSAverage,
			GlobalProductShelvingAverage: globalProductShelvingAverage,
			GlobalBOHAverage:             globalBOHAverage,
			GlobalBasinAverage:           globalBasinAverage,
			GlobalFurnitureAverage:       globalFurnitureAverage,
			GlobalLightingAverage:        globalLightingAverage,
			GlobalFixturesAverage:        globalFixturesAverage,
			GlobalCSFAverage:             globalCSFAverage,
			GlobalFFAverage:              globalFFAverage,
			GlobalMUAverage:              globalMUAverage,
		}

		c.JSON(http.StatusOK, response)
	}
}
func MaterialScores(c *gin.Context) {
	n := c.Params.ByName("n")

	i, err := strconv.Atoi(n)
	if err != nil {
		c.AbortWithStatus(http.StatusNotFound)
	}

	var materials []MaterialInstance

	if result := Config.DB.Find(&materials); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		// if value provided is greater than number of stores in db
		if i > len(materials) {
			i = len(materials)
		}

		// sort materials by total score get highest
		sort.Slice(materials[:], func(i, j int) bool {
			return materials[i].TotalScore > materials[j].TotalScore
		})

		tmp := materials[:i]
		highestRatedMaterials := make([]MaterialInstance, len(tmp))
		copy(highestRatedMaterials, tmp)

		// sort materials by total score get highest
		sort.Slice(materials[:], func(i, j int) bool {
			return materials[i].TotalScore < materials[j].TotalScore
		})

		lowestRatedMaterials := materials[:i]

		response := MaterialScoresResponse{
			HighestRatedMaterials: highestRatedMaterials,
			LowestRatedMaterials:  lowestRatedMaterials,
		}

		c.JSON(http.StatusOK, response)
	}
}
func TopMaterialsArchitectId(c *gin.Context) {
	id := c.Params.ByName("architectId")

	var materials []MaterialInstance

	if result := Config.DB.Where("creatorId = ?", id).Find(&materials); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {

		// sort materials by total score get highest
		sort.Slice(materials[:], func(i, j int) bool {
			return materials[i].TotalScore > materials[j].TotalScore
		})
		// change the slice number to get top x
		c.JSON(http.StatusOK, materials[:5])
	}
}
func ScoresArchitectId(c *gin.Context) {
	id := c.Params.ByName("architectId")

	var stores []Store

	if result := Config.DB.Where("architectId = ?", id).Where("storeStatus <> ?", "DRAFT").Find(&stores); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {

		var tempStoreScores []float32

		for _, store := range stores {
			tempStoreScores = append(tempStoreScores, store.TotalScore)
		}

		averageStoreScore := average(tempStoreScores)

		// sort stores by total score get highest
		sort.Slice(stores[:], func(i, j int) bool {
			return stores[i].TotalScore > stores[j].TotalScore
		})

		var highestStoreScore float32

		if len(stores) > 0 {
			highestStoreScore = stores[0].TotalScore
		} else {
			highestStoreScore = 0
		}

		response := ScoresArchitectIdResponse{
			AverageStoreScore: averageStoreScore,
			HighestStoreScore: highestStoreScore,
		}

		// change the slice number to get top x
		c.JSON(http.StatusOK, response)
	}
}

// DeleteCommentsCommentId -
func DeleteCommentsCommentId(c *gin.Context) {
	var comment Comment
	id := c.Params.ByName("commentId")
	if result := Config.DB.Where("id = ?", id).Delete(&comment); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, gin.H{"commentId " + id: "is deleted"})
	}
}

// DeleteMaterialTypesMaterialTypeId -
func DeleteMaterialTypesMaterialTypeId(c *gin.Context) {
	var materialType MaterialType
	id := c.Params.ByName("materialTypeId")
	if result := Config.DB.Where("id = ?", id).Delete(&materialType); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, gin.H{"materialTypeId " + id: "is deleted"})
	}
}

// DeleteMaterialInstanceMaterialInstanceId -
func DeleteMaterialInstanceMaterialInstanceId(c *gin.Context) {
	var materialInstance MaterialInstance
	id := c.Params.ByName("materialInstanceId")
	var storeId int32

	if result := Config.DB.Where("id = ?", id).Find(&materialInstance); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		fmt.Println(materialInstance.StoreId)
		storeId = materialInstance.StoreId
	}

	if result := Config.DB.Where("id = ?", id).Delete(&materialInstance); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		// recalculate store id
		fmt.Println(storeId)
		setStoreScores(storeId)
		c.JSON(http.StatusOK, gin.H{"materialInstanceId " + id: "is deleted"})
	}
}

// DeleteStoresStoreId -
func DeleteStoresStoreId(c *gin.Context) {
	var store Store
	id := c.Params.ByName("userId")
	if result := Config.DB.Where("id = ?", id).Delete(&store); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, gin.H{"storeId " + id: "is deleted"})
	}
}

// DeleteUsersUserId -
func DeleteUsersUserId(c *gin.Context) {
	var user User
	id := c.Params.ByName("userId")
	if result := Config.DB.Where("id = ?", id).Delete(&user); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, gin.H{"userId " + id: "is deleted"})
	}
}

// GetCommentsMaterialInstanceId - Your GET endpoint
func GetCommentsMaterialInstanceId(c *gin.Context) {
	id := c.Params.ByName("materialInstanceId")
	var allMaterialComments []Comment

	if result := Config.DB.Where("materialInstanceId = ?", id).Find(&allMaterialComments); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, allMaterialComments)
	}
}

// GetEpicMaterials - Your GET endpoint
func GetEpicMaterials(c *gin.Context) {
	var epicMaterials []EpicMaterial

	if result := Config.DB.Find(&epicMaterials); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, epicMaterials)
	}
}

func GetCertifications(c *gin.Context) {
	var certifications []Certification

	if result := Config.DB.Find(&certifications); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, certifications)
	}
}

// GetEpicMaterialsEpicMaterialId - Your GET endpoint
func GetEpicMaterialsEpicMaterialId(c *gin.Context) {
	id := c.Params.ByName("materialTypeId")
	var epicMaterial EpicMaterial

	if result := Config.DB.Where("id = ?", id).First(&epicMaterial); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, epicMaterial)
	}
}

// GetMaterialInstanceHistoryMaterialInstanceId - Your GET endpoint
func GetMaterialInstanceHistoryMaterialInstanceId(c *gin.Context) {
	id := c.Params.ByName("materialInstanceId")
	var materialInstance MaterialInstance
	var materialInstanceHistory []MaterialInstanceHistory

	if result := Config.DB.Where("id = ?", id).Find(&materialInstance); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		if result := Config.DB.Where("materialInstanceId = ?", id).Find(&materialInstanceHistory); result.Error != nil {
			c.AbortWithStatus(http.StatusNotFound)
		} else {
			c.JSON(http.StatusOK, MaterialInstanceHistoryResponse{materialInstance, materialInstanceHistory})
		}
	}
}

func GetStoresArchitectId(c *gin.Context) {
	id := c.Params.ByName("architectId")
	var stores []Store

	if result := Config.DB.Where("architectId = ?", id).Find(&stores); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, stores)
	}
}

func GetStoresContractorId(c *gin.Context) {
	id := c.Params.ByName("contractorId")
	var stores []Store

	if result := Config.DB.Where("contractorId = ?", id).Find(&stores); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, stores)
	}
}

// GetMaterialInstancesStoreId - Your GET endpoint
func GetMaterialInstancesStoreId(c *gin.Context) {
	id := c.Params.ByName("storeId")
	var materialInstances []MaterialInstance

	if result := Config.DB.Where("storeId = ?", id).Find(&materialInstances); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, materialInstances)
	}
}

// GetMaterialTypes - Your GET endpoint
func GetMaterialTypes(c *gin.Context) {
	var materialTypes []MaterialType

	if result := Config.DB.Find(&materialTypes); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, materialTypes)
	}
}

// GetMaterialTypesMaterialTypeId - Your GET endpoint
func GetMaterialTypesMaterialTypeId(c *gin.Context) {
	id := c.Params.ByName("materialTypeId")
	var materialType MaterialType

	if result := Config.DB.Where("id = ?", id).First(&materialType); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, materialType)
	}
}

// GetStores - Your GET endpoint
func GetStores(c *gin.Context) {
	var stores []Store

	if result := Config.DB.Find(&stores); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, stores)
	}
}

// GetStoresStoreId - Your GET endpoint
func GetStoresStoreId(c *gin.Context) {
	id := c.Params.ByName("storeId")
	var store Store

	if result := Config.DB.Where("id = ?", id).First(&store); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, store)
	}
}

// GetUsers - Your GET endpoint
func GetUsers(c *gin.Context) {
	var users []User

	if result := Config.DB.Find(&users); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, users)
	}
}

// GetUsersUserId - Get User Info by User ID
func GetUsersUserId(c *gin.Context) {
	id := c.Params.ByName("userId")
	var user User

	if result := Config.DB.Where("id = ?", id).First(&user); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, user)
	}
}

// PostComment -
func PostComment(c *gin.Context) {
	var comment Comment
	c.BindJSON(&comment)

	comment.CommentDate = time.Now().UTC().Format("2006-01-02T15:04:05Z")

	if result := Config.DB.Create(&comment); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, comment)
	}
}

// PostMaterialInstance -
func PostMaterialInstance(c *gin.Context) {
	var materialInstance MaterialInstance
	c.BindJSON(&materialInstance)

	// pass incoming material instance to function
	// set values based on lookups in calcs
	setMaterialScores(&materialInstance)

	// update store totals function call
	// setStoreScores()

	//testing
	// fmt.Println(materialInstance)
	// c.JSON(http.StatusOK, materialInstance)

	if result := Config.DB.Create(&materialInstance); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		setStoreScores(materialInstance.StoreId)
		c.JSON(http.StatusOK, materialInstance)
	}
}

// PostMaterialType -
func PostMaterialType(c *gin.Context) {
	var materialType MaterialType
	c.BindJSON(&materialType)

	if result := Config.DB.Create(&materialType); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, materialType)
	}
}

// PostStore -
func PostStore(c *gin.Context) {
	var store Store
	c.BindJSON(&store)

	if result := Config.DB.Create(&store); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, store)
	}
}

// PostUser - Create New User
func PostUser(c *gin.Context) {
	var user User
	c.BindJSON(&user)

	user.CreatedDate = time.Now().UTC().Format("2006-01-02T15:04:05Z")

	if result := Config.DB.Create(&user); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.JSON(http.StatusOK, user)
	}
}

// PutMaterialInstancesMaterialInstanceId -
func PutMaterialInstancesMaterialInstanceId(c *gin.Context) {
	id := c.Params.ByName("materialInstanceId")
	var materialInstance MaterialInstance

	// check if material exists
	if result := Config.DB.Where("id = ?", id).First(&materialInstance); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		// get body of request, assign to variable
		c.BindJSON(&materialInstance)

		// pass incoming material instance to function
		// set values based on lookups in calcs
		setMaterialScores(&materialInstance)

		// update store totals function call
		// setStoreScores()

		//testing
		// fmt.Println(materialInstance)
		// c.JSON(http.StatusOK, materialInstance)

		if result := Config.DB.Save(&materialInstance); result.Error != nil {
			c.AbortWithStatus(http.StatusNotFound)
		} else {
			setStoreScores(materialInstance.StoreId)
			c.JSON(http.StatusOK, materialInstance)
		}
	}
}

// PutMaterialTypesMaterialTypeId -
func PutMaterialTypesMaterialTypeId(c *gin.Context) {
	id := c.Params.ByName("materialTypeId")
	var materialType MaterialType

	if result := Config.DB.Where("id = ?", id).First(&materialType); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.BindJSON(&materialType)
		if result := Config.DB.Save(&materialType); result.Error != nil {
			c.AbortWithStatus(http.StatusNotFound)
		} else {
			c.JSON(http.StatusOK, materialType)
		}
	}
}

// PutStoresStoreId -
func PutStoresStoreId(c *gin.Context) {
	id := c.Params.ByName("storeId")
	var store Store

	if result := Config.DB.Where("id = ?", id).First(&store); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.BindJSON(&store)
		if result := Config.DB.Save(&store); result.Error != nil {
			c.AbortWithStatus(http.StatusNotFound)
		} else {
			c.JSON(http.StatusOK, store)
		}
	}
}

// PutUsersUserId -
func PutUsersUserId(c *gin.Context) {
	id := c.Params.ByName("userId")
	var user User

	if result := Config.DB.Where("id = ?", id).First(&user); result.Error != nil {
		c.AbortWithStatus(http.StatusNotFound)
	} else {
		c.BindJSON(&user)
		if result := Config.DB.Save(&user); result.Error != nil {
			c.AbortWithStatus(http.StatusNotFound)
		} else {
			c.JSON(http.StatusOK, user)
		}
	}

}
